"""Malicious PDF handling security tests.

This module contains tests for handling various types of malicious PDF files
and attack vectors specific to PDF processing.
"""

import pytest
import os
import time
import threading
from pathlib import Path
from unittest.mock import patch, MagicMock

from smart_pdf_toolkit.core.interfaces import OperationResult
from .security_fixtures import (
    security_temp_dir, security_config, pdf_operations_secure,
    create_malicious_pdf, security_logger
)


class TestMaliciousPDFDetection:
    """Test detection and handling of malicious PDF files."""
    
    def test_pdf_bomb_detection(self, pdf_operations_secure, create_malicious_pdf, security_temp_dir):
        \"\"\"Test detection of PDF bombs (files that expand excessively when processed).\"\"\"
        # Create a potential PDF bomb
        pdf_bomb = create_malicious_pdf(\"pdf_bomb.pdf\", \"zip_bomb\")\n        \n        # Try to process it with timeout protection\n        start_time = time.time()\n        result = pdf_operations_secure.split_pdf(str(pdf_bomb), str(security_temp_dir / \"bomb_output\"))\n        processing_time = time.time() - start_time\n        \n        # Should either complete quickly or timeout gracefully\n        assert processing_time < 30  # Should not take more than 30 seconds\n        assert isinstance(result.success, bool)\n        \n        if not result.success:\n            # Should have appropriate error message\n            error_indicators = [\"timeout\", \"size\", \"memory\", \"invalid\", \"malformed\"]\n            assert any(indicator in result.message.lower() for indicator in error_indicators)\n    \n    def test_javascript_pdf_sanitization(self, pdf_operations_secure, create_malicious_pdf, security_temp_dir):\n        \"\"\"Test sanitization of PDFs with embedded JavaScript.\"\"\"\n        js_pdf = create_malicious_pdf(\"javascript.pdf\", \"javascript\")\n        output_path = security_temp_dir / \"sanitized_js.pdf\"\n        \n        # Process the PDF with JavaScript\n        result = pdf_operations_secure.rotate_pdf(str(js_pdf), [90], str(output_path))\n        \n        # Should handle JavaScript PDFs safely\n        assert isinstance(result.success, bool)\n        \n        if result.success and output_path.exists():\n            # Check that JavaScript is removed or neutralized\n            with open(output_path, 'rb') as f:\n                content = f.read()\n                # Should not contain dangerous JavaScript patterns\n                dangerous_patterns = [b'app.alert', b'this.print', b'eval(', b'document.']\n                for pattern in dangerous_patterns:\n                    assert pattern not in content\n    \n    def test_embedded_file_extraction_prevention(self, pdf_operations_secure, create_malicious_pdf, security_temp_dir):\n        \"\"\"Test prevention of malicious embedded file extraction.\"\"\"\n        # Create PDF with potentially malicious embedded files\n        embedded_pdf = create_malicious_pdf(\"embedded_malware.pdf\", \"embedded_files\")\n        \n        # Try to extract content\n        result = pdf_operations_secure.extract_text(str(embedded_pdf))\n        \n        # Should handle embedded files safely\n        assert isinstance(result.success, bool)\n        \n        # Check that no executable files were extracted to temp directories\n        temp_files = list(security_temp_dir.glob(\"**/*\"))\n        for temp_file in temp_files:\n            if temp_file.is_file():\n                # Should not extract executable files\n                dangerous_extensions = ['.exe', '.bat', '.scr', '.com', '.pif']\n                assert not any(str(temp_file).lower().endswith(ext) for ext in dangerous_extensions)\n    \n    def test_infinite_loop_pdf_handling(self, pdf_operations_secure, create_malicious_pdf, security_temp_dir):\n        \"\"\"Test handling of PDFs designed to cause infinite loops.\"\"\"\n        loop_pdf = create_malicious_pdf(\"infinite_loop.pdf\", \"infinite_loop\")\n        \n        # Process with timeout\n        def process_with_timeout():\n            return pdf_operations_secure.merge_pdfs([str(loop_pdf)], str(security_temp_dir / \"loop_output.pdf\"))\n        \n        # Use threading to implement timeout\n        result_container = []\n        \n        def worker():\n            try:\n                result = process_with_timeout()\n                result_container.append(result)\n            except Exception as e:\n                result_container.append(OperationResult(False, f\"Exception: {e}\"))\n        \n        thread = threading.Thread(target=worker)\n        thread.start()\n        thread.join(timeout=15)  # 15 second timeout\n        \n        if thread.is_alive():\n            # Thread is still running, likely infinite loop\n            # In a real implementation, we would terminate the thread\n            assert False, \"PDF processing appears to be in infinite loop\"\n        \n        # Should have completed within timeout\n        assert len(result_container) == 1\n        result = result_container[0]\n        assert isinstance(result.success, bool)\n    \n    def test_memory_exhaustion_pdf_handling(self, pdf_operations_secure, create_malicious_pdf, security_temp_dir):\n        \"\"\"Test handling of PDFs designed to exhaust memory.\"\"\"\n        memory_bomb_pdf = create_malicious_pdf(\"memory_bomb.pdf\", \"memory_bomb\")\n        \n        # Monitor memory usage\n        import psutil\n        process = psutil.Process()\n        initial_memory = process.memory_info().rss\n        \n        # Process the PDF\n        result = pdf_operations_secure.rotate_pdf(str(memory_bomb_pdf), [90], str(security_temp_dir / \"memory_output.pdf\"))\n        \n        # Check memory usage\n        final_memory = process.memory_info().rss\n        memory_increase = final_memory - initial_memory\n        \n        # Should not consume excessive memory\n        assert memory_increase < 500 * 1024 * 1024  # Less than 500MB increase\n        assert isinstance(result.success, bool)\n    \n    def test_corrupted_pdf_handling(self, pdf_operations_secure, security_temp_dir):\n        \"\"\"Test handling of corrupted PDF files.\"\"\"\n        # Create various types of corrupted PDFs\n        corrupted_pdfs = [\n            (\"truncated.pdf\", b\"%PDF-1.4\\n1 0 obj\\n<< /Type /Catalog\"),  # Truncated\n            (\"invalid_header.pdf\", b\"INVALID\\n%PDF-1.4\\n%%EOF\\n\"),  # Invalid header\n            (\"mixed_content.pdf\", b\"%PDF-1.4\\n\" + b\"\\x00\\xFF\" * 1000 + b\"\\n%%EOF\\n\"),  # Mixed binary\n            (\"empty.pdf\", b\"\"),  # Empty file\n            (\"null_bytes.pdf\", b\"\\x00\" * 1000),  # Only null bytes\n        ]\n        \n        for filename, content in corrupted_pdfs:\n            corrupted_pdf = security_temp_dir / filename\n            with open(corrupted_pdf, 'wb') as f:\n                f.write(content)\n            \n            # Try to process corrupted PDF\n            result = pdf_operations_secure.split_pdf(str(corrupted_pdf), str(security_temp_dir / f\"corrupted_output_{filename}\"))\n            \n            # Should fail gracefully\n            assert not result.success\n            assert \"invalid\" in result.message.lower() or \"corrupted\" in result.message.lower() or \"malformed\" in result.message.lower()\n\n\nclass TestPDFExploitPrevention:\n    \"\"\"Test prevention of PDF-based exploits.\"\"\"\n    \n    def test_buffer_overflow_prevention(self, pdf_operations_secure, security_temp_dir):\n        \"\"\"Test prevention of buffer overflow attacks via PDF content.\"\"\"\n        # Create PDF with extremely long strings\n        overflow_pdf = security_temp_dir / \"buffer_overflow.pdf\"\n        \n        with open(overflow_pdf, 'wb') as f:\n            f.write(b'%PDF-1.4\\n')\n            f.write(b'1 0 obj\\n')\n            f.write(b'<< /Type /Catalog /Title (')\n            f.write(b'A' * 100000)  # Very long title\n            f.write(b') >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'%%EOF\\n')\n        \n        # Process the PDF\n        result = pdf_operations_secure.extract_text(str(overflow_pdf))\n        \n        # Should handle long strings safely\n        assert isinstance(result.success, bool)\n        # Should not crash the application\n    \n    def test_format_string_attack_prevention(self, pdf_operations_secure, security_temp_dir):\n        \"\"\"Test prevention of format string attacks.\"\"\"\n        # Create PDF with format string patterns\n        format_pdf = security_temp_dir / \"format_string.pdf\"\n        \n        format_strings = [b'%s%s%s%s', b'%x%x%x%x', b'%n%n%n%n']\n        \n        with open(format_pdf, 'wb') as f:\n            f.write(b'%PDF-1.4\\n')\n            f.write(b'1 0 obj\\n')\n            f.write(b'<< /Type /Catalog /Subject (')\n            f.write(b''.join(format_strings))\n            f.write(b') >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'%%EOF\\n')\n        \n        # Process the PDF\n        result = pdf_operations_secure.rotate_pdf(str(format_pdf), [90], str(security_temp_dir / \"format_output.pdf\"))\n        \n        # Should handle format strings safely\n        assert isinstance(result.success, bool)\n    \n    def test_path_injection_prevention(self, pdf_operations_secure, security_temp_dir):\n        \"\"\"Test prevention of path injection attacks via PDF metadata.\"\"\"\n        # Create PDF with malicious paths in metadata\n        path_injection_pdf = security_temp_dir / \"path_injection.pdf\"\n        \n        malicious_paths = [\n            b'../../../etc/passwd',\n            b'..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam',\n            b'/dev/null',\n            b'CON',\n            b'file\\x00hidden.exe'\n        ]\n        \n        with open(path_injection_pdf, 'wb') as f:\n            f.write(b'%PDF-1.4\\n')\n            f.write(b'1 0 obj\\n')\n            f.write(b'<< /Type /Catalog')\n            for i, path in enumerate(malicious_paths):\n                f.write(f' /Custom{i} ('.encode())\n                f.write(path)\n                f.write(b')')\n            f.write(b' >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'%%EOF\\n')\n        \n        # Process the PDF\n        result = pdf_operations_secure.merge_pdfs([str(path_injection_pdf)], str(security_temp_dir / \"path_output.pdf\"))\n        \n        # Should handle malicious paths safely\n        assert isinstance(result.success, bool)\n        \n        # Verify no files were created in unexpected locations\n        dangerous_locations = [\n            Path('/etc/passwd'),\n            Path('/tmp/malicious'),\n            Path('C:\\\\Windows\\\\System32\\\\malicious.exe')\n        ]\n        \n        for location in dangerous_locations:\n            if location.exists():\n                assert False, f\"Malicious file created at {location}\"\n    \n    def test_command_injection_prevention(self, pdf_operations_secure, security_temp_dir):\n        \"\"\"Test prevention of command injection via PDF processing.\"\"\"\n        # Create PDF with command injection patterns\n        command_pdf = security_temp_dir / \"command_injection.pdf\"\n        \n        command_injections = [\n            b'; rm -rf /',\n            b'| cat /etc/passwd',\n            b'&& format c:',\n            b'`rm -rf /`',\n            b'$(rm -rf /)',\n            b'%{rm -rf /}'\n        ]\n        \n        with open(command_pdf, 'wb') as f:\n            f.write(b'%PDF-1.4\\n')\n            f.write(b'1 0 obj\\n')\n            f.write(b'<< /Type /Catalog /Producer (')\n            f.write(b''.join(command_injections))\n            f.write(b') >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'%%EOF\\n')\n        \n        # Process the PDF\n        result = pdf_operations_secure.split_pdf(str(command_pdf), str(security_temp_dir / \"command_output\"))\n        \n        # Should handle command injection attempts safely\n        assert isinstance(result.success, bool)\n        \n        # Verify no unexpected system changes occurred\n        # (In a real test, we would check for specific system changes)\n\n\nclass TestPDFContentSanitization:\n    \"\"\"Test sanitization of PDF content.\"\"\"\n    \n    def test_metadata_sanitization(self, pdf_operations_secure, security_temp_dir):\n        \"\"\"Test sanitization of PDF metadata.\"\"\"\n        # Create PDF with potentially dangerous metadata\n        metadata_pdf = security_temp_dir / \"dangerous_metadata.pdf\"\n        \n        with open(metadata_pdf, 'wb') as f:\n            f.write(b'%PDF-1.4\\n')\n            f.write(b'1 0 obj\\n')\n            f.write(b'<< /Type /Catalog')\n            f.write(b' /Title (<script>alert(\\'xss\\')</script>)')\n            f.write(b' /Author (javascript:alert(\\'xss\\'))')\n            f.write(b' /Subject (data:text/html,<script>alert(\\'xss\\')</script>)')\n            f.write(b' /Keywords (\\x00\\x01\\x02\\x03)')\n            f.write(b' >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'%%EOF\\n')\n        \n        # Process the PDF\n        output_path = security_temp_dir / \"sanitized_metadata.pdf\"\n        result = pdf_operations_secure.rotate_pdf(str(metadata_pdf), [90], str(output_path))\n        \n        # Should sanitize dangerous metadata\n        if result.success and output_path.exists():\n            with open(output_path, 'rb') as f:\n                content = f.read()\n                # Should not contain dangerous patterns\n                dangerous_patterns = [b'<script>', b'javascript:', b'data:text/html']\n                for pattern in dangerous_patterns:\n                    assert pattern not in content\n    \n    def test_form_field_sanitization(self, pdf_operations_secure, security_temp_dir):\n        \"\"\"Test sanitization of PDF form fields.\"\"\"\n        # Create PDF with malicious form fields\n        form_pdf = security_temp_dir / \"malicious_form.pdf\"\n        \n        with open(form_pdf, 'wb') as f:\n            f.write(b'%PDF-1.4\\n')\n            f.write(b'1 0 obj\\n')\n            f.write(b'<< /Type /Catalog /AcroForm << /Fields [')\n            f.write(b'<< /T (username) /V (<script>alert(\\'xss\\')</script>) >>')\n            f.write(b'<< /T (password) /V (javascript:steal_password()) >>')\n            f.write(b'] >> >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'%%EOF\\n')\n        \n        # Process the PDF\n        result = pdf_operations_secure.extract_text(str(form_pdf))\n        \n        # Should handle form fields safely\n        assert isinstance(result.success, bool)\n    \n    def test_annotation_sanitization(self, pdf_operations_secure, security_temp_dir):\n        \"\"\"Test sanitization of PDF annotations.\"\"\"\n        # Create PDF with malicious annotations\n        annotation_pdf = security_temp_dir / \"malicious_annotations.pdf\"\n        \n        with open(annotation_pdf, 'wb') as f:\n            f.write(b'%PDF-1.4\\n')\n            f.write(b'1 0 obj\\n')\n            f.write(b'<< /Type /Catalog /Pages 2 0 R >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'2 0 obj\\n')\n            f.write(b'<< /Type /Pages /Kids [3 0 R] /Count 1 >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'3 0 obj\\n')\n            f.write(b'<< /Type /Page /Parent 2 0 R /Annots [')\n            f.write(b'<< /Type /Annot /Subtype /Link /A << /S /URI /URI (javascript:alert(\\'xss\\')) >> >>')\n            f.write(b'<< /Type /Annot /Subtype /Text /Contents (<script>alert(\\'xss\\')</script>) >>')\n            f.write(b'] >>\\n')\n            f.write(b'endobj\\n')\n            f.write(b'%%EOF\\n')\n        \n        # Process the PDF\n        output_path = security_temp_dir / \"sanitized_annotations.pdf\"\n        result = pdf_operations_secure.merge_pdfs([str(annotation_pdf)], str(output_path))\n        \n        # Should sanitize dangerous annotations\n        if result.success and output_path.exists():\n            with open(output_path, 'rb') as f:\n                content = f.read()\n                # Should not contain dangerous JavaScript URIs\n                assert b'javascript:alert' not in content\n                assert b'<script>' not in content\n"